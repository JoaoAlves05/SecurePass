 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/extension/src/hibp.js b/extension/src/hibp.js
index 7d37160b6ad786f1b10fbf51cc47848872b353ec..f45af6b457c9dd98cadc3845b382315e29acc1b0 100644
--- a/extension/src/hibp.js
+++ b/extension/src/hibp.js
@@ -30,51 +30,62 @@ async function getCacheTtl() {
   const settings = await loadSettings();
   const hours = settings.hibpCacheTtlHours || 24;
   return hours * 60 * 60 * 1000;
 }
 
 export async function checkPassword(password) {
   if (!password) {
     return { compromised: false, count: 0 };
   }
 
   const hash = await sha1(password);
   const prefix = hash.substring(0, 5);
   const suffix = hash.substring(5);
   const cacheKey = `${prefix}`;
   const cache = await getCache();
 
   const entry = cache[cacheKey];
   const now = Date.now();
   let responseText;
 
   const cacheTtl = await getCacheTtl();
 
   if (entry && now - entry.timestamp < cacheTtl) {
     responseText = entry.payload;
   } else {
-    const res = await fetch(API_URL + prefix, {
-      method: 'GET',
-      headers: {
-        'Add-Padding': 'true'
+    let res;
+    try {
+      res = await fetch(API_URL + prefix, {
+        method: 'GET',
+        headers: {
+          'Add-Padding': 'true'
+        }
+      });
+    } catch (error) {
+      if (error instanceof TypeError) {
+        // Some environments block custom headers (triggering a CORS failure).
+        // Retry without the padding header so the lookup can still succeed.
+        res = await fetch(API_URL + prefix, { method: 'GET' });
+      } else {
+        throw error;
       }
-    });
+    }
     if (!res.ok) {
       throw new Error(`HIBP request failed with status ${res.status}`);
     }
     responseText = await res.text();
     cache[cacheKey] = {
       payload: responseText,
       timestamp: now
     };
     await setCache(cache);
   }
 
   const lines = responseText.split('\n');
   for (const line of lines) {
     const [hashSuffix, count] = line.trim().split(':');
     if (hashSuffix === suffix) {
       return { compromised: true, count: parseInt(count, 10) };
     }
   }
   return { compromised: false, count: 0 };
 }
 
EOF
)